diff --git a/in/ac/iitd/src/main/java/index/bplusTree/BPlusTreeIndexFile.java b/in/ac/iitd/src/main/java/index/bplusTree/BPlusTreeIndexFile.java
index 4d23ef0..30fc03f 100644
--- a/in/ac/iitd/src/main/java/index/bplusTree/BPlusTreeIndexFile.java
+++ b/in/ac/iitd/src/main/java/index/bplusTree/BPlusTreeIndexFile.java
@@ -73,6 +73,269 @@ public class BPlusTreeIndexFile<T> extends AbstractFile<BlockNode> {
     public void insert(T key, int block_id) {
 
         /* Write your code here */
+        int order = getOrder();
+        int split_point = order / 2;
+
+//        System.out.println("-KB pair- " + key + " : " + block_id);
+
+        // Root is a LeafNode
+        if (isLeaf(blocks.get(getRootId()))) {
+            LeafNode<T> root = (LeafNode<T>) blocks.get(getRootId());
+            if (!isFull(getRootId())) {
+                root.insert(key, block_id);
+            }
+            else {
+                LeafNode<T> newNode1 = new LeafNode<>(typeClass);
+                LeafNode<T> newNode2 = new LeafNode<>(typeClass);
+                T[] keys = root.getKeys();
+                int[] blockIds = root.getBlockIds();
+                T new_root_key = null;
+                int i = 0, j = 0;
+                while (i < split_point) {
+                    if (j == i && root.compare(keys[j], key) > 0) {
+                        newNode1.insert(key, block_id);
+//                        if (i == (order-1) / 2) {
+//                            new_root_key = key;
+//                        }
+                    } else {
+                        newNode1.insert(keys[j], blockIds[j]);
+//                        if (i == (order-1) / 2) {
+//                            new_root_key = keys[j];
+//                        }
+                        j++;
+                    }
+                    i++;
+                }
+//                System.out.println("--t2--- ");
+//                for (T eokey : newNode1.getKeys()) {
+//                    System.out.print(eokey + " ");
+//                }
+//                System.out.println();
+                while (i < order) {
+                    if (j == order - 1 || (j == i && root.compare(keys[j], key) > 0)) {
+                        newNode2.insert(key, block_id);
+                        if (i == split_point) {
+                            new_root_key = key;
+                        }
+                    } else {
+                        newNode2.insert(keys[j], blockIds[j]);
+                        if (i == split_point) {
+                            new_root_key = keys[j];
+                        }
+                        j++;
+                    }
+                    i++;
+                }
+//                System.out.println("--t2--- ");
+//                for (T eokey : newNode2.getKeys()) {
+//                    System.out.print(eokey + " ");
+//                }
+//                System.out.println();
+                int node1_id = blocks.size();
+                int node2_id = node1_id + 1;
+                newNode2.set_prev_node_id(node1_id);
+                newNode1.set_next_node_id(node2_id);
+                blocks.add(newNode1);
+                blocks.add(newNode2);
+                InternalNode<T> newRoot = new InternalNode<>(new_root_key, node1_id, node2_id, typeClass);
+                blocks.set(getRootId(), newRoot);
+            }
+        } else {
+            int node_id = getRootId();
+            ArrayList<Integer> parents = new ArrayList<>();
+            while (!isLeaf(node_id)) {
+                parents.add(node_id);
+                InternalNode<T> node = (InternalNode<T>) blocks.get(node_id);
+                node_id = node.search(key);
+            }
+            LeafNode<T> node = (LeafNode<T>) blocks.get(node_id);
+            T[] keys = node.getKeys();
+
+//            System.out.println("Key-Node: " + key + ", " + node_id);
+
+            //System.out.println("-----LEN----" + keys.length);
+//            for (T eokey : keys) {
+                //System.out.println(eokey);
+//            }
+            //System.out.println("------------");
+
+//            ----------- To check for other empty eligible leaf nodes.
+//            while (isFull(node_id) && node.compare(key, keys[keys.length-1]) == 0 && node.get_next_node_id() != 0) {
+//                node_id = node.get_next_node_id();
+//                node = (LeafNode<T>) blocks.get(node_id);
+//            }
+
+            if (!isFull(node_id)) {
+                node.insert(key, block_id);
+            } else {
+                LeafNode<T> newNode1 = new LeafNode<>(typeClass);
+                LeafNode<T> newNode2 = new LeafNode<>(typeClass);
+                int[] blockIds = node.getBlockIds();
+                T new_key = null;
+                int i = 0, j = 0;
+                while (i < split_point) {
+                    if (j == i && node.compare(keys[j], key) > 0) {
+                        newNode1.insert(key, block_id);
+//                        if (i == (order - 1) / 2) {
+//                            new_key = key;
+//                        }
+                    } else {
+                        newNode1.insert(keys[j], blockIds[j]);
+//                        if (i == (order - 1) / 2) {
+//                            new_key = keys[j];
+//                        }
+                        j++;
+                    }
+                    i++;
+                }
+
+                //System.out.println("--t2--- ");
+//                for (T eokey : newNode1.getKeys()) {
+                      //System.out.print(eokey + " ");
+//                }
+                while (i < order) {
+                    if (j == order - 1 || (j == i && node.compare(keys[j], key) > 0)) {
+                        newNode2.insert(key, block_id);
+                        if (i == split_point) {
+                            new_key = key;
+                        }
+                    } else {
+                        newNode2.insert(keys[j], blockIds[j]);
+                        if (i == split_point) {
+                            new_key = keys[j];
+                        }
+                        j++;
+                    }
+                    i++;
+                }
+                int right_child_id = blocks.size();
+                int next_node_id = node.get_next_node_id();
+
+                newNode1.set_prev_node_id(node.get_prev_node_id());
+                newNode1.set_next_node_id(right_child_id);
+                newNode2.set_prev_node_id(node_id);
+
+                //System.out.print("--t3--- ");
+//                for (T eokey : newNode2.getKeys()) {
+                      //System.out.print(eokey + " ");
+//                }
+                //System.out.println("--************-- ");
+
+                blocks.set(node_id, newNode1);
+                blocks.add(newNode2);
+
+                if (next_node_id > 0) {
+                    LeafNode<T> next_node = (LeafNode<T>) blocks.get(next_node_id);
+                    newNode2.set_next_node_id(next_node_id);
+                    next_node.set_prev_node_id(right_child_id);
+                    blocks.set(next_node_id, next_node);
+                }
+                //System.out.println("---- " + next_node_id + " ----");
+                //System.out.println("--NK-- " + new_key + " ----");
+
+                for (int pid = parents.size() - 1; pid >= 0; pid--) {
+                    InternalNode<T> parent = (InternalNode<T>) blocks.get(parents.get(pid));
+                    //System.out.println("Parent id: " + pid);
+                    if (!isFull(parents.get(pid))) {
+                        parent.insert(new_key, right_child_id);
+                        break;
+                    } else {
+                        int[] child_ids = parent.getChildren();
+                        T[] parent_keys = parent.getKeys();
+                        ArrayList<T> keys1 = new ArrayList<>();
+                        ArrayList<T> keys2 = new ArrayList<>();
+                        ArrayList<Integer> children1 = new ArrayList<>();
+                        ArrayList<Integer> children2 = new ArrayList<>();
+                        children1.add(child_ids[0]);
+                        i = 0; j = 0;
+                        while (i < order / 2) {
+                            if (j == i && node.compare(parent_keys[j], new_key) > 0) {
+                                keys1.add(new_key);
+                                children1.add(right_child_id);
+                            } else {
+                                keys1.add(parent_keys[j]);
+                                children1.add(child_ids[j+1]);
+                                j++;
+                            }
+                            i++;
+                        }
+
+                        // // ////System.out.println("Keys1");
+//                        for (T eokey : keys1) {
+                            // // ////System.out.print(eokey + " ");
+//                        }
+                        // // ////System.out.println();
+
+                        T old_key = new_key;
+                        if (j == order -1 || (j == i && node.compare(parent_keys[j], new_key) > 0)) {
+                            children2.add(right_child_id);
+                        } else {
+                            new_key = parent_keys[j];
+                            children2.add(child_ids[j+1]);
+                            j++;
+                        }
+                        i++;
+
+                        // // ////System.out.println("NewKey");
+                        // // ////System.out.println(new_key);
+                        // // ////System.out.println();
+
+                        while (i < order) {
+                            if (j == order -1 || (j == i && node.compare(parent_keys[j], new_key) > 0)) {
+                                keys2.add(old_key);
+                                children2.add(right_child_id);
+                            } else {
+                                keys2.add(parent_keys[j]);
+                                children2.add(child_ids[j+1]);
+                                j++;
+                            }
+                            i++;
+                        }
+
+                        // // ////System.out.println("Keys2");
+//                        for (T eokey : keys2) {
+                            // // ////System.out.print(eokey + " ");
+//                        }
+                        // // ////System.out.println();
+
+                        InternalNode<T> inode1 = new InternalNode<>(keys1.get(0), children1.get(0), children1.get(1), typeClass);
+                        InternalNode<T> inode2 = new InternalNode<>(keys2.get(0), children2.get(0), children2.get(1), typeClass);
+                        for (i = 1; i < keys1.size(); i++) {
+                            inode1.insert(keys1.get(i), children1.get(i+1));
+                        }
+
+//                        for (T eokey : inode1.getKeys()) {
+                            //System.out.print(eokey + " ");
+//                        }
+                        //System.out.println();
+
+                        for (i = 1; i < keys2.size(); i++) {
+                            inode2.insert(keys2.get(i), children2.get(i+1));
+                        }
+
+//                        for (T eokey : inode2.getKeys()) {
+                            //System.out.print(eokey + " ");
+//                        }
+                        //System.out.println("#### " + pid + " ####");
+                        //System.out.println("--- " + new_key + " ---");
+
+                        if (pid == 0) {
+                            assert (parents.get(pid) == getRootId());
+                            int left_child_id = blocks.size();
+                            blocks.add(inode1);
+                            right_child_id = blocks.size();
+                            blocks.add(inode2);
+                            InternalNode<T> newRoot = new InternalNode<>(new_key, left_child_id, right_child_id, typeClass);
+                            blocks.set(parents.get(pid), newRoot);
+                        } else {
+                            blocks.set(parents.get(pid), inode1);
+                            right_child_id = blocks.size();
+                            blocks.add(inode2);
+                        }
+                    }
+                }
+            }
+        }
         return;
     }
 
@@ -81,7 +344,49 @@ public class BPlusTreeIndexFile<T> extends AbstractFile<BlockNode> {
     public int search(T key) {
 
         /* Write your code here */
-        return -1;
+        int node_id = getRootId();
+        while (!isLeaf(node_id)) {
+            InternalNode<T> node = (InternalNode<T>) blocks.get(node_id);
+            node_id = node.search(key);
+//            for (T eokey : node.getKeys()) {
+//                System.out.print(eokey + " ");
+//            }
+//            System.out.println();
+        }
+        LeafNode<T> node = (LeafNode<T>) blocks.get(node_id);
+        if (node.search(key) == -1) {
+            T[] keys = node.getKeys();
+            for (T key_ : keys) {
+                if (node.compare(key_, key) > 0) {
+                    return node_id;
+                }
+            }
+            if (node.get_next_node_id() == 0) {
+                return -1;
+            }
+            return node.get_next_node_id();
+        }
+//        for (T eokey : node.getKeys()) {
+//            System.out.print(eokey + " ");
+//        }
+//        System.out.println();
+//        System.out.println("Last node:" + node_id);
+
+        while (node.get_prev_node_id() != 0) {
+            int prev_node_id = node.get_prev_node_id();
+            node = (LeafNode<T>) blocks.get(prev_node_id);
+//            for (T eokey : node.getKeys()) {
+//                System.out.print(eokey + " ");
+//            }
+//            System.out.println();
+            if (node.search(key) == -1) {
+                break;
+            }
+            node_id = prev_node_id;
+        }
+//        LeafNode<T> node = (LeafNode<T>) blocks.get(node_id);
+//        return node.search(key);
+        return node_id;
     }
 
     // returns true if the key was found and deleted, false otherwise
@@ -96,9 +401,13 @@ public class BPlusTreeIndexFile<T> extends AbstractFile<BlockNode> {
     public void print_bfs() {
         int root = getRootId();
         Queue<Integer> queue = new LinkedList<>();
+        Queue<Integer> level = new LinkedList<>();
         queue.add(root);
+        level.add(0);
         while(!queue.isEmpty()) {
             int id = queue.remove();
+            int lev = level.remove();
+//            System.out.print("\nLevel " + lev + ": ");
             if(isLeaf(id)) {
                 ((LeafNode<T>) blocks.get(id)).print();
             }
@@ -107,6 +416,7 @@ public class BPlusTreeIndexFile<T> extends AbstractFile<BlockNode> {
                 int[] children = ((InternalNode<T>) blocks.get(id)).getChildren();
                 for(int i = 0; i < children.length; i++) {
                     queue.add(children[i]);
+                    level.add(lev + 1);
                 }
             }
         }
diff --git a/in/ac/iitd/src/main/java/index/bplusTree/InternalNode.java b/in/ac/iitd/src/main/java/index/bplusTree/InternalNode.java
index 2217aec..de8362b 100644
--- a/in/ac/iitd/src/main/java/index/bplusTree/InternalNode.java
+++ b/in/ac/iitd/src/main/java/index/bplusTree/InternalNode.java
@@ -48,6 +48,15 @@ public class InternalNode<T> extends BlockNode implements TreeNode<T> {
         T[] keys = (T[]) new Object[numKeys];
 
         /* Write your code here */
+        byte[] nextFreeOffsetBytes = this.get_data(2, 2);
+        int nextFreeOffset = (nextFreeOffsetBytes[0] << 8) | (nextFreeOffsetBytes[1] & 0xFF);
+        int pointer = 6, i = 0;
+        while (pointer < nextFreeOffset) {
+            byte[] keyLenBytes = this.get_data(pointer, 2);
+            int keyLen = (keyLenBytes[0] << 8) | (keyLenBytes[1] & 0xFF);
+            keys[i++] = convertBytesToT(this.get_data(pointer + 2, keyLen), typeClass);
+            pointer += keyLen + 4;
+        }
 
         return keys;
     }
@@ -56,14 +65,117 @@ public class InternalNode<T> extends BlockNode implements TreeNode<T> {
     @Override
     public void insert(T key, int right_block_id) {
         /* Write your code here */
+        byte[] nextFreeOffsetBytes = this.get_data(2, 2);
+        int nextFreeOffset = (nextFreeOffsetBytes[0] << 8) | (nextFreeOffsetBytes[1] & 0xFF);
+
+        byte[] keyLenBytes = new byte[2];
+        if (typeClass == Integer.class) {
+            keyLenBytes[0] = 0;
+            keyLenBytes[1] = 4;
+        } else if (typeClass == Boolean.class) {
+            keyLenBytes[0] = 0;
+            keyLenBytes[1] = 1;
+        } else if (typeClass == Double.class) {
+            keyLenBytes[0] = 0;
+            keyLenBytes[1] = 8;
+        } else if (typeClass == Float.class) {
+            keyLenBytes[0] = 0;
+            keyLenBytes[1] = 4;
+        } else if (typeClass == String.class) {
+            keyLenBytes[0] = (byte) ((key.toString().length() >> 8) & 0xFF);
+            keyLenBytes[1] = (byte) (key.toString().length() & 0xFF);
+        }
+        int keyLen = (keyLenBytes[0] << 8) | (keyLenBytes[1] & 0xFF);
+
+        byte[] keyBytes = new byte[keyLen];
+        if (typeClass == Integer.class) {
+            keyBytes[0] = (byte) (((Integer) key >> 24) & 0xFF);
+            keyBytes[1] = (byte) (((Integer) key >> 16) & 0xFF);
+            keyBytes[2] = (byte) (((Integer) key >> 8) & 0xFF);
+            keyBytes[3] = (byte) ((Integer) key & 0xFF);
+        } else if (typeClass == Boolean.class) {
+            keyBytes[0] = (byte) ((Boolean) key ? 1 : 0);
+        } else if (typeClass == Double.class) {
+            keyBytes = new byte[8];
+            for (int i = 0; i < 8; i++) {
+                keyBytes[i] = (byte) ((Double.doubleToLongBits((Double) key) >> (8 * (7 - i))) & 0xFF);
+            }
+        } else if (typeClass == Float.class) {
+            keyBytes = new byte[4];
+            for (int i = 0; i < 4; i++) {
+                keyBytes[i] = (byte) ((Float.floatToIntBits((Float) key) >> (8 * (3 - i))) & 0xFF);
+            }
+        } else if (typeClass == String.class) {
+            keyBytes = key.toString().getBytes();
+        }
+
+        byte[] blockIdBytes = new byte[2];
+        blockIdBytes[0] = (byte) ((right_block_id >> 8) & 0xFF);
+        blockIdBytes[1] = (byte) (right_block_id & 0xFF);
+
+        int pointer = 6, i = 0;
+        while (pointer < nextFreeOffset) {
+            byte[] keyLenBytes_ = this.get_data(pointer, 2);
+            int keyLen_ = (keyLenBytes_[0] << 8) | (keyLenBytes_[1] & 0xFF);
+            byte[] keyBytes_ = this.get_data(pointer + 2, keyLen_);
+            T key_ = convertBytesToT(keyBytes_, typeClass);
+            if (compare(key, key_) < 0) {
+                break;
+            }
+            pointer += keyLen_ + 4;
+        }
+        if (pointer < nextFreeOffset) {
+            byte[] temp = this.get_data(pointer, nextFreeOffset - pointer);
+            this.write_data(pointer + 4 + keyLen, temp);
+        }
+        this.write_data(pointer, keyLenBytes);
+        this.write_data(pointer + 2, keyBytes);
+        this.write_data(pointer + 2 + keyLen, blockIdBytes);
+
+        nextFreeOffset += 4 + keyLen;
+        nextFreeOffsetBytes[0] = (byte) ((nextFreeOffset >> 8) & 0xFF);
+        nextFreeOffsetBytes[1] = (byte) (nextFreeOffset & 0xFF);
+        this.write_data(2, nextFreeOffsetBytes);
 
+        int numEntries = getNumKeys() + 1;
+        byte[] numEntriesBytes = new byte[2];
+        numEntriesBytes[0] = (byte) ((numEntries >> 8) & 0xFF);
+        numEntriesBytes[1] = (byte) (numEntries & 0xFF);
+        this.write_data(0, numEntriesBytes);
+        return;
     }
 
     // can be used as helper function - won't be evaluated
     @Override
     public int search(T key) {
         /* Write your code here */
-        return -1;
+        byte[] nextFreeOffsetBytes = this.get_data(2, 2);
+        int nextFreeOffset = (nextFreeOffsetBytes[0] << 8) | (nextFreeOffsetBytes[1] & 0xFF);
+
+        byte[] childIdBytes = this.get_data(4, 2);
+        int childId = (childIdBytes[0] << 8) | (childIdBytes[1] & 0xFF);
+
+        int pointer = 6, i = 1;
+        while (pointer < nextFreeOffset) {
+            byte[] keyLenBytes = this.get_data(pointer, 2);
+            int keyLen = (keyLenBytes[0] << 8) | (keyLenBytes[1] & 0xFF);
+
+            byte[] fnd_key_bytes = this.get_data(pointer + 2, keyLen);
+            T fnd_key = convertBytesToT(fnd_key_bytes, typeClass);
+            if (compare(key, fnd_key) < 0) {
+//                System.out.println("key: " + key + " fnd_key: " + fnd_key);
+                return childId;
+            }
+
+            childIdBytes = this.get_data(pointer + keyLen + 2, 2);
+            childId = (childIdBytes[0] << 8) | (childIdBytes[1] & 0xFF);
+//            if (compare(key, fnd_key) == 0) {
+//                return childId;
+//            }
+
+            pointer += keyLen + 4;
+        }
+        return childId;
     }
 
     // should return the block_ids of the children - will be evaluated
@@ -75,9 +187,25 @@ public class InternalNode<T> extends BlockNode implements TreeNode<T> {
         int[] children = new int[numKeys + 1];
 
         /* Write your code here */
+        byte[] nextFreeOffsetBytes = this.get_data(2, 2);
+        int nextFreeOffset = (nextFreeOffsetBytes[0] << 8) | (nextFreeOffsetBytes[1] & 0xFF);
 
-        return children;
+        byte[] childIdBytes = this.get_data(4, 2);
+        children[0] = (childIdBytes[0] << 8) | (childIdBytes[1] & 0xFF);
+
+        int pointer = 6, i = 1;
+        while (pointer < nextFreeOffset) {
+            byte[] keyLenBytes = this.get_data(pointer, 2);
+            int keyLen = (keyLenBytes[0] << 8) | (keyLenBytes[1] & 0xFF);
 
+            childIdBytes = this.get_data(pointer + keyLen + 2, 2);
+            int childId = (childIdBytes[0] << 8) | (childIdBytes[1] & 0xFF);
+
+            children[i++] = childId;
+            pointer += keyLen + 4;
+        }
+
+        return children;
     }
 
 }
diff --git a/in/ac/iitd/src/main/java/index/bplusTree/LeafNode.java b/in/ac/iitd/src/main/java/index/bplusTree/LeafNode.java
index 2d20b35..f9ccb4b 100644
--- a/in/ac/iitd/src/main/java/index/bplusTree/LeafNode.java
+++ b/in/ac/iitd/src/main/java/index/bplusTree/LeafNode.java
@@ -1,5 +1,7 @@
 package index.bplusTree;
 
+import com.sun.org.apache.xpath.internal.operations.Bool;
+
 /*
     * A LeafNode contains keys and block ids.
     * Looks Like -
@@ -39,6 +41,18 @@ public class LeafNode<T> extends BlockNode implements TreeNode<T>{
         T[] keys = (T[]) new Object[numKeys];
 
         /* Write your code here */
+        byte[] nextFreeOffsetBytes = this.get_data(6, 2);
+        int nextFreeOffset = (nextFreeOffsetBytes[0] << 8) | (nextFreeOffsetBytes[1] & 0xFF);
+
+
+        int pointer = 10, i = 0;
+        while (pointer < nextFreeOffset) {
+            byte[] keyLenBytes = this.get_data(pointer, 2);
+            int keyLen = (keyLenBytes[0] << 8) | (keyLenBytes[1] & 0xFF);
+
+            keys[i++] = convertBytesToT(this.get_data(pointer + 2, keyLen), typeClass);
+            pointer += keyLen + 4;
+        }
 
         return keys;
 
@@ -52,6 +66,16 @@ public class LeafNode<T> extends BlockNode implements TreeNode<T>{
         int[] block_ids = new int[numKeys];
 
         /* Write your code here */
+        byte[] nextFreeOffsetBytes = this.get_data(6, 2);
+        int nextFreeOffset = (nextFreeOffsetBytes[0] << 8) | (nextFreeOffsetBytes[1] & 0xFF);
+
+        int pointer = 8, i = 0;
+        while (pointer < nextFreeOffset) {
+            byte[] blockId_keyLen_Bytes = this.get_data(pointer, 4);
+            block_ids[i++] = (blockId_keyLen_Bytes[0] << 8) | (blockId_keyLen_Bytes[1] & 0xFF);
+            int keyLen = (blockId_keyLen_Bytes[2] << 8) | (blockId_keyLen_Bytes[3] & 0xFF);
+            pointer += keyLen + 4;
+        }
 
         return block_ids;
     }
@@ -60,11 +84,86 @@ public class LeafNode<T> extends BlockNode implements TreeNode<T>{
     @Override
     public void insert(T key, int block_id) {
 
-
         /* Write your code here */
+        byte[] nextFreeOffsetBytes = this.get_data(6, 2);
+        int nextFreeOffset = (nextFreeOffsetBytes[0] << 8) | (nextFreeOffsetBytes[1] & 0xFF);
+
+        byte[] blockIdBytes = new byte[2];
+        blockIdBytes[0] = (byte) ((block_id >> 8) & 0xFF);
+        blockIdBytes[1] = (byte) (block_id & 0xFF);
+
+        byte[] keyLenBytes = new byte[2];
+        if (typeClass == Integer.class) {
+            keyLenBytes[0] = 0;
+            keyLenBytes[1] = 4;
+        } else if (typeClass == Boolean.class) {
+            keyLenBytes[0] = 0;
+            keyLenBytes[1] = 1;
+        } else if (typeClass == Double.class) {
+            keyLenBytes[0] = 0;
+            keyLenBytes[1] = 8;
+        } else if (typeClass == Float.class) {
+            keyLenBytes[0] = 0;
+            keyLenBytes[1] = 4;
+        } else if (typeClass == String.class) {
+            keyLenBytes[0] = (byte) ((key.toString().length() >> 8) & 0xFF);
+            keyLenBytes[1] = (byte) (key.toString().length() & 0xFF);
+        }
+        int keyLen = (keyLenBytes[0] << 8) | (keyLenBytes[1] & 0xFF);
+
+        byte[] keyBytes = new byte[keyLen];
+        if (typeClass == Integer.class) {
+            keyBytes[0] = (byte) (((Integer) key >> 24) & 0xFF);
+            keyBytes[1] = (byte) (((Integer) key >> 16) & 0xFF);
+            keyBytes[2] = (byte) (((Integer) key >> 8) & 0xFF);
+            keyBytes[3] = (byte) ((Integer) key & 0xFF);
+        } else if (typeClass == Boolean.class) {
+            keyBytes[0] = (byte) ((Boolean) key ? 1 : 0);
+        } else if (typeClass == Double.class) {
+            keyBytes = new byte[8];
+            for (int i = 0; i < 8; i++) {
+                keyBytes[i] = (byte) ((Double.doubleToLongBits((Double) key) >> (8 * (7 - i))) & 0xFF);
+            }
+        } else if (typeClass == Float.class) {
+            keyBytes = new byte[4];
+            for (int i = 0; i < 4; i++) {
+                keyBytes[i] = (byte) ((Float.floatToIntBits((Float) key) >> (8 * (3 - i))) & 0xFF);
+            }
+        } else if (typeClass == String.class) {
+            keyBytes = key.toString().getBytes();
+        }
+
+        int pointer = 8, i = 0;
+        while (pointer < nextFreeOffset) {
+            byte[] blockId_keyLen_Bytes = this.get_data(pointer, 4);
+            int keyLen_ = (blockId_keyLen_Bytes[2] << 8) | (blockId_keyLen_Bytes[3] & 0xFF);
+            byte[] fnd_key_bytes = this.get_data(pointer + 4, keyLen_);
+            T fnd_key = convertBytesToT(fnd_key_bytes, typeClass);
+            if (compare(key, fnd_key) < 0) {
+                break;
+            }
+            pointer += keyLen_ + 4;
+        }
+
+        if (pointer < nextFreeOffset) {
+            byte[] temp = this.get_data(pointer, nextFreeOffset - pointer);
+            this.write_data(pointer + 4 + keyLen, temp);
+        }
+        this.write_data(pointer, blockIdBytes);
+        this.write_data(pointer + 2, keyLenBytes);
+        this.write_data(pointer + 4, keyBytes);
+
+        nextFreeOffset += 4 + keyLen;
+        nextFreeOffsetBytes[0] = (byte) ((nextFreeOffset >> 8) & 0xFF);
+        nextFreeOffsetBytes[1] = (byte) (nextFreeOffset & 0xFF);
+        this.write_data(6, nextFreeOffsetBytes);
 
+        int numEntries = getNumKeys() + 1;
+        byte[] numEntriesBytes = new byte[2];
+        numEntriesBytes[0] = (byte) ((numEntries >> 8) & 0xFF);
+        numEntriesBytes[1] = (byte) (numEntries & 0xFF);
+        this.write_data(0, numEntriesBytes);
         return;
-
     }
 
     // can be used as helper function - won't be evaluated
@@ -72,7 +171,53 @@ public class LeafNode<T> extends BlockNode implements TreeNode<T>{
     public int search(T key) {
 
         /* Write your code here */
-        return -1;
+        byte[] nextFreeOffsetBytes = this.get_data(6, 2);
+        int nextFreeOffset = (nextFreeOffsetBytes[0] << 8) | (nextFreeOffsetBytes[1] & 0xFF);
+
+        int ans_block_id = -1;
+        int pointer = 8, i = 0;
+        while (pointer < nextFreeOffset) {
+            byte[] blockId_keyLen_Bytes = this.get_data(pointer, 4);
+            int block_id = (blockId_keyLen_Bytes[0] << 8) | (blockId_keyLen_Bytes[1] & 0xFF);
+            int keyLen = (blockId_keyLen_Bytes[2] << 8) | (blockId_keyLen_Bytes[3] & 0xFF);
+            byte[] fnd_key_bytes = this.get_data(pointer + 4, keyLen);
+            T fnd_key = convertBytesToT(fnd_key_bytes, typeClass);
+//            if (compare(key, fnd_key) < 0) {
+//                return ans_block_id;
+//            }
+            if (compare(key, fnd_key) == 0) {
+                return block_id;
+            }
+//            ans_block_id = block_id;
+            pointer += keyLen + 4;
+        }
+        return ans_block_id;
+    }
+
+    public void set_prev_node_id(int prev_node_id) {
+        byte[] prev_node_id_bytes = new byte[2];
+        prev_node_id_bytes[0] = (byte) ((prev_node_id >> 8) & 0xFF);
+        prev_node_id_bytes[1] = (byte) (prev_node_id & 0xFF);
+        this.write_data(2, prev_node_id_bytes);
+        return;
+    }
+
+    public void set_next_node_id(int next_node_id) {
+        byte[] next_node_id_bytes = new byte[2];
+        next_node_id_bytes[0] = (byte) ((next_node_id >> 8) & 0xFF);
+        next_node_id_bytes[1] = (byte) (next_node_id & 0xFF);
+        this.write_data(4, next_node_id_bytes);
+        return;
+    }
+
+    public int get_prev_node_id() {
+        byte[] prev_node_id_bytes = this.get_data(2, 2);
+        return (prev_node_id_bytes[0] << 8) | (prev_node_id_bytes[1] & 0xFF);
+    }
+
+    public int get_next_node_id() {
+        byte[] next_node_id_bytes = this.get_data(4, 2);
+        return (next_node_id_bytes[0] << 8) | (next_node_id_bytes[1] & 0xFF);
     }
 
 }
diff --git a/in/ac/iitd/src/main/java/index/bplusTree/TreeNode.java b/in/ac/iitd/src/main/java/index/bplusTree/TreeNode.java
index 1315e6b..71d6f72 100644
--- a/in/ac/iitd/src/main/java/index/bplusTree/TreeNode.java
+++ b/in/ac/iitd/src/main/java/index/bplusTree/TreeNode.java
@@ -1,5 +1,7 @@
 package index.bplusTree;
 
+import java.nio.ByteBuffer;
+
 // TreeNode interface - will be implemented by InternalNode and LeafNode
 public interface TreeNode <T> {
 
@@ -21,8 +23,41 @@ public interface TreeNode <T> {
     default public T convertBytesToT(byte[] bytes, Class<T> typeClass){
         
         /* Write your code here */
-
+        if (typeClass == Integer.class) {
+            return (T) Integer.valueOf((bytes[0] << 24) | (bytes[1] << 16) | (bytes[2] << 8) | (bytes[3] & 0xFF));
+        }
+        if (typeClass == Boolean.class) {
+            return (T) Boolean.valueOf(bytes[0] == 1);
+        }
+        if (typeClass == Double.class) {
+            return (T) Double.valueOf(ByteBuffer.wrap(bytes).getDouble());
+        }
+        if (typeClass == Float.class) {
+            return (T) Float.valueOf(ByteBuffer.wrap(bytes).getFloat());
+        }
+        if (typeClass == String.class) {
+            return (T) new String(bytes);
+        }
         return null;
     }
-    
+
+    default public int compare(T key1, T key2) {
+        if (key1 instanceof Integer) {
+            return Integer.compare((Integer) key1, (Integer) key2);
+        }
+        if (key1 instanceof Boolean) {
+            return Boolean.compare((Boolean) key1, (Boolean) key2);
+        }
+        if (key1 instanceof Double) {
+            return Double.compare((Double) key1, (Double) key2);
+        }
+        if (key1 instanceof Float) {
+            return Float.compare((Float) key1, (Float) key2);
+        }
+        if (key2 instanceof String) {
+            return ((String) key1).compareTo((String) key2);
+        }
+        return 0;
+    }
+
 }
\ No newline at end of file
diff --git a/in/ac/iitd/src/main/java/manager/StorageManager.java b/in/ac/iitd/src/main/java/manager/StorageManager.java
index c1eb28a..58028cc 100644
--- a/in/ac/iitd/src/main/java/manager/StorageManager.java
+++ b/in/ac/iitd/src/main/java/manager/StorageManager.java
@@ -1,5 +1,6 @@
 package manager;
 
+import index.bplusTree.BPlusTreeIndexFile;
 import storage.DB;
 import storage.File;
 import storage.Block;
@@ -8,9 +9,7 @@ import Utils.CsvRowConverter;
 import java.io.BufferedReader;
 import java.io.FileReader;
 import java.io.IOException;
-import java.util.HashMap;
-import java.util.List;
-import java.util.ArrayList;
+import java.util.*;
 
 import org.apache.calcite.rel.type.RelDataType;
 import org.apache.calcite.rex.RexLiteral;
@@ -21,8 +20,6 @@ import org.json.simple.JSONObject;
 import org.json.simple.parser.JSONParser;
 import org.json.simple.parser.ParseException;
 
-import java.util.Iterator;
-
 public class StorageManager {
 
     private HashMap<String, Integer> file_to_fileid;
@@ -303,6 +300,8 @@ public class StorageManager {
         num_columns[0] = (byte) (columnNames.size() & 0xFF);
         num_columns[1] = (byte) ((columnNames.size() >> 8) & 0xFF);
 
+//        System.out.println("Number of columns injected: " + columnNames.size());
+
         schema.write_data(0, num_columns);
 
         int idx = 0, curr_offset = schema.get_block_capacity();
@@ -324,6 +323,7 @@ public class StorageManager {
                 assert(columnNames.get(i).length() < 256);
 
                 column_name_type[0] = (byte) (ColumnType.valueOf(typeList.get(i).getSqlTypeName().getName()).ordinal() & 0xFF);
+//                System.out.println("Column name type:" + column_name_type[0] + ", " + columnNames.get(i));
                 column_name_type[1] = (byte) (columnNames.get(i).length() & 0xFF);
                 for(int j = 0; j < columnNames.get(i).length(); j++) {
                     column_name_type[2 + j] = (byte) columnNames.get(i).charAt(j);
@@ -387,17 +387,191 @@ public class StorageManager {
         /* Write your code here */
         // return null if file does not exist, or block_id is invalid
         // return list of records otherwise
-        return null;
+
+        if(!check_file_exists(table_name)) {
+            return null;
+        }
+        if (block_id <= 0 || db.get_data(file_to_fileid.get(table_name), block_id) == null) {
+            return null;
+        }
+        byte[] schemaBlock = get_data_block(table_name, 0);
+        int num_columns = (schemaBlock[0] & 0xFF) | (schemaBlock[1] << 8);
+
+//        System.out.println("NUM cols:" + num_columns);
+
+        String[] typeList = new String[num_columns];
+        int num_fixed = 0, num_var = 0;
+        for (int i = 0; i < num_columns; i++) {
+            byte[] offsetBytes = new byte[2];
+            offsetBytes[0] = schemaBlock[2 + 2 * i];
+            offsetBytes[1] = schemaBlock[3 + 2 * i];
+            int col_offsets = (offsetBytes[0] & 0xFF) | (offsetBytes[1] << 8);
+            int col_type_ind = schemaBlock[col_offsets] & 0xFF;
+            typeList[i] = ColumnType.values()[col_type_ind].name();
+            if (typeList[i].equals("VARCHAR")) {
+                num_var++;
+            } else {
+                num_fixed++;
+            }
+        }
+//        System.out.println("FIXED = " + num_fixed + " VAR = " + num_var);
+        byte[] blockBytes = get_data_block(table_name, block_id);
+        int num_records = (blockBytes[0] << 8) | (blockBytes[1] & 0xFF);
+//        System.out.println("NUM Records: " + num_records);
+        List<Object[]> records = new ArrayList<>();
+        int offset_pointer = 2;
+        for (int i = 0; i < num_records; i++) {
+            int pointer = (blockBytes[offset_pointer] << 8) | (blockBytes[offset_pointer + 1] & 0xFF);
+            offset_pointer += 2;
+
+            Object[] record = new Object[num_columns];
+            int[] var_offset = new int[num_var];
+            int[] var_length = new int[num_var];
+            for (int j = 0; j < num_var; j++) {
+                var_offset[j] = (blockBytes[pointer] & 0xFF) | (blockBytes[pointer + 1] << 8);
+                var_length[j] = (blockBytes[pointer + 2] & 0xFF) | (blockBytes[pointer + 3] << 8);
+                pointer += 4;
+            }
+            byte[] null_bitmap = new byte[(num_columns + 7) / 8];
+//            System.out.println("NULL BITMAP LENGTH: " + null_bitmap.length);
+//            System.out.println("VAR_offset 0 : " + var_offset[0]);
+            System.arraycopy(blockBytes, var_offset[0] - null_bitmap.length, null_bitmap, 0, null_bitmap.length);
+
+            for (int j = 0; j < num_fixed; j++) {
+                if ((null_bitmap[j / 8] & (1 << (7 - j % 8))) == 1) {
+                    record[j] = null;
+                } else {
+                    switch (typeList[j]) {
+                        case "INTEGER": {
+                            int val = (blockBytes[pointer] & 0xFF) | (blockBytes[pointer + 1] << 8) | (blockBytes[pointer + 2] << 16) | (blockBytes[pointer + 3] << 24);
+                            record[j] = val;
+                            break;
+                        }
+                        case "BOOLEAN":
+                            record[j] = blockBytes[pointer] == 1;
+                            break;
+                        case "FLOAT": {
+                            int val = (blockBytes[pointer] & 0xFF) | (blockBytes[pointer + 1] << 8) | (blockBytes[pointer + 2] << 16) | (blockBytes[pointer + 3] << 24);
+                            record[j] = Float.intBitsToFloat(val);
+                            break;
+                        }
+                        case "DOUBLE": {
+                            long val = (blockBytes[pointer] & 0xFF) | (blockBytes[pointer + 1] << 8) | (blockBytes[pointer + 2] << 16) | (blockBytes[pointer + 3] << 24) | ((long) blockBytes[pointer + 4] << 32) | ((long) blockBytes[pointer + 5] << 40) | ((long) blockBytes[pointer + 6] << 48) | ((long) blockBytes[pointer + 7] << 56);
+                            record[j] = Double.longBitsToDouble(val);
+                            break;
+                        }
+                    }
+                }
+            }
+
+            for (int j = 0; j < num_var; j++) {
+                byte[] col_data = new byte[var_length[j]];
+                if (var_length[j] >= 0) System.arraycopy(blockBytes, var_offset[j], col_data, 0, var_length[j]);
+                if ((null_bitmap[(num_fixed + j) / 8] & (1 << (7 - (num_fixed + j) % 8))) == 1) {
+                    record[num_fixed + j] = null;
+                } else {
+                    record[num_fixed + j] = new String(col_data);
+                }
+            }
+            records.add(record);
+        }
+
+        return records;
     }
 
     public boolean create_index(String table_name, String column_name, int order) {
         /* Write your code here */
-        return false;
+        // Hint: You need to create a new index file and write the index blocks
+
+        byte[] schemaBlock = get_data_block(table_name, 0);
+        int num_columns = (schemaBlock[0] & 0xFF) | (schemaBlock[1] << 8);
+//        System.out.println("Number of columns retrieved: " + num_columns);
+//        System.out.println("Column name to index: " + column_name);
+        String[] typeList = new String[num_columns];
+        String[] col_names = new String[num_columns];
+        int num_fixed = 0, num_var = 0;
+        int col_ind_in_record = -1;
+        for (int i = 0; i < num_columns; i++) {
+            int col_offset = (schemaBlock[2 + 2 * i] & 0xFF) | (schemaBlock[3 + 2 * i] << 8);
+//            System.out.println("COL Offset:" + col_offset);
+            int col_type_ind = schemaBlock[col_offset] & 0xFF;
+//            System.out.println("COL TYPE ind:" + col_type_ind);
+            int col_name_len = schemaBlock[col_offset + 1] & 0xFF;
+            typeList[i] = ColumnType.values()[col_type_ind].name();
+//            System.out.println("Retrieved Typename:" + typeList[i]);
+            if (typeList[i].equals("VARCHAR")) {
+                num_var++;
+            } else {
+                num_fixed++;
+            }
+            byte[] col_name_bytes = new byte[col_name_len];
+            for (int j = 0; j < col_name_len; j++) {
+                col_name_bytes[j] = schemaBlock[col_offset + 2 + j];
+            }
+            col_names[i] = new String(col_name_bytes);
+            if (col_names[i].equals(column_name)) {
+                col_ind_in_record = i;
+            }
+        }
+//        System.out.println();
+//        System.out.println(col_ind_in_record);
+        assert (col_ind_in_record >= 0);
+
+        BPlusTreeIndexFile indexFile = null;
+        switch (typeList[col_ind_in_record]) {
+            case "INTEGER":
+                indexFile = new BPlusTreeIndexFile<>(order, Integer.class);
+                break;
+            case "BOOLEAN":
+                indexFile = new BPlusTreeIndexFile<>(order, Boolean.class);
+                break;
+            case "FLOAT":
+                indexFile = new BPlusTreeIndexFile<>(order, Float.class);
+                break;
+            case "DOUBLE":
+                indexFile = new BPlusTreeIndexFile<>(order, Double.class);
+                break;
+            case "VARCHAR":
+                indexFile = new BPlusTreeIndexFile<>(order, String.class);
+                break;
+        }
+
+        int block_id = 1;
+        List<Object[]> records = get_records_from_block(table_name, block_id);
+        while (records != null) {
+//            System.out.println("NUM Records: " + records.size());
+            for (Object[] record : records) {
+//                System.out.println("REcord = " + record[col_ind_in_record]);
+                indexFile.insert(record[col_ind_in_record], block_id);
+//                System.out.println("Index Block = " + indexFile.get_num_blocks());
+            }
+            block_id++;
+//            System.out.println("Block id = "+ block_id);
+            records = get_records_from_block(table_name, block_id);
+        }
+//        System.out.println("NUM Blocks: " + indexFile.get_num_blocks());
+        int index_file_id = db.addFile(indexFile);
+        file_to_fileid.put(table_name + "_" + column_name + "_index", index_file_id);
+        return true;
     }
 
     // returns the block_id of the leaf node where the key is present
     public int search(String table_name, String column_name, RexLiteral value) {
         /* Write your code here */
+        if(check_index_exists(table_name, column_name)) {
+            Object val = null;
+            if (value.getType().toString().equals("INTEGER")) val = value.getValueAs(Integer.class);
+            else if (value.getType().toString().equals("FLOAT")) val = value.getValueAs(Float.class);
+            else if (value.getType().toString().equals("DOUBLE")) val = value.getValueAs(Double.class);
+            else if (value.getType().toString().equals("VARCHAR")) val = value.getValueAs(String.class);
+            else if (value.getType().toString().equals("BOOLEAN")) val = value.getValueAs(Boolean.class);
+//            System.out.println("Value = " + value);
+            int file_id = file_to_fileid.get(table_name + "_" + column_name + "_index");
+//            System.out.println("file id = " + file_id);
+            return db.search_index(file_id, val);
+        } else {
+            System.out.println("Index does not exist");
+        }
         return -1;
     }
 
diff --git a/in/ac/iitd/src/main/java/optimizer/rel/PIndexScan.java b/in/ac/iitd/src/main/java/optimizer/rel/PIndexScan.java
index db265b7..cb9ae31 100644
--- a/in/ac/iitd/src/main/java/optimizer/rel/PIndexScan.java
+++ b/in/ac/iitd/src/main/java/optimizer/rel/PIndexScan.java
@@ -6,10 +6,18 @@ import org.apache.calcite.plan.RelTraitSet;
 import org.apache.calcite.rel.RelNode;
 import org.apache.calcite.rel.core.TableScan;
 import org.apache.calcite.rel.type.RelDataType;
+import org.apache.calcite.rex.RexCall;
+import org.apache.calcite.rex.RexInputRef;
+import org.apache.calcite.rex.RexLiteral;
 import org.apache.calcite.rex.RexNode;
 
 import manager.StorageManager;
+import org.apache.calcite.sql.type.SqlTypeName;
 
+import java.nio.ByteBuffer;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
 import java.util.List;
 
 // Operator trigged when doing indexed scan
@@ -54,7 +62,368 @@ public class PIndexScan extends TableScan implements PRel {
             System.out.println("Evaluating PIndexScan for table: " + tableName);
 
             /* Write your code here */
+            RexCall filterCall = (RexCall) filter;
+            RexNode columnRef = filterCall.getOperands().get(0);
+            RexInputRef inputRef = (RexInputRef) columnRef;
+            int columnInd = inputRef.getIndex();
+            String op_name = filterCall.getOperator().getName();
+//            System.out.println("Column ind: " + columnInd);
+//            System.out.println("Filter condition: " + op_name);
 
-            return null;
+            byte[] schemaBlock = storage_manager.get_data_block(tableName, 0);
+            String columnName = "";
+            int num_fixed = 0, num_var = 0;
+            int col_offset = (schemaBlock[2 + 2 * columnInd] & 0xFF) | (schemaBlock[3 + 2 * columnInd] << 8);
+            int col_name_len = schemaBlock[col_offset + 1] & 0xFF;
+            byte[] col_name_bytes = new byte[col_name_len];
+            for (int j = 0; j < col_name_len; j++) {
+                col_name_bytes[j] = schemaBlock[col_offset + 2 + j];
+            }
+            columnName = new String(col_name_bytes);
+//            System.out.println("Column Name: " + columnName);
+
+            RexLiteral key_to_search = (RexLiteral) filterCall.getOperands().get(1);
+            String operand_type = key_to_search.getType().toString();
+//            System.out.println("Operand: " + key_to_search + " of type " + key_to_search.getType().toString());
+//            assert (key_to_search.getType().toString().equals("INTEGER"));
+
+            HashSet<Integer> explored_block_records = new HashSet<>();
+
+            List<Object[]> records = new ArrayList<>();
+            int leaf_block_id = storage_manager.search(tableName, columnName, key_to_search);
+//            System.out.println("LEAF BLOCK ID: " + leaf_block_id);
+            if (leaf_block_id == -1) {
+                if (op_name.equals("<=") || op_name.equals("<")) {
+                    int block_id = 1;
+                    List<Object[]> record_i = storage_manager.get_records_from_block(tableName, block_id);
+                    while (record_i != null) {
+                        records.addAll(record_i);
+                        block_id++;
+                        record_i = storage_manager.get_records_from_block(tableName, block_id);
+                    }
+                }
+                return records;
+            } else {
+                byte[] leaf_data = storage_manager.get_data_block(tableName + "_" + columnName + "_index", leaf_block_id);
+                if (op_name.equals("=")) {
+                    while (true) {
+                        int num_keys = (leaf_data[0] << 8) | (leaf_data[1] & 0xFF);
+                        //System.out.println(num_keys);
+                        int next_leaf_block_id = (leaf_data[4] << 8) | (leaf_data[5] & 0xFF);
+                        int nextFreeOffset = (leaf_data[6] << 8) | (leaf_data[7] & 0xFF);
+                        int pointer = 8, i = 0;
+                        while (pointer < nextFreeOffset) {
+                            int block_id = (leaf_data[pointer] << 8) | (leaf_data[pointer + 1] & 0xFF);
+                            int keyLen = (leaf_data[pointer + 2] << 8) | (leaf_data[pointer + 3] & 0xFF);
+                            if (explored_block_records.contains(block_id)) {
+                                pointer += keyLen + 4;
+                                continue;
+                            }
+
+                            byte[] fnd_key_bytes = new byte[keyLen];
+                            System.arraycopy(leaf_data, pointer + 4, fnd_key_bytes, 0, keyLen);
+                            if (operand_type.equals("INTEGER")) {
+                                Integer key = Integer.valueOf((fnd_key_bytes[0] << 24) | (fnd_key_bytes[1] << 16) | (fnd_key_bytes[2] << 8) | (fnd_key_bytes[3] & 0xFF));
+                                //System.out.println("parsed KEY: " + key);
+
+                                Integer search_key = key_to_search.getValueAs(Integer.class);
+                                if (key.equals(search_key)) {
+                                    List<Object[]> record_i = storage_manager.get_records_from_block(tableName, block_id);
+                                    for (Object[] record : record_i) {
+                                        if (record[columnInd].equals(search_key)) {
+                                            records.add(record);
+                                        }
+                                    }
+                                    explored_block_records.add(block_id);
+                                }
+                                if (key.compareTo(search_key) > 0) {
+                                    break;
+                                }
+                            } else if (operand_type.equals("BOOLEAN")) {
+                                Boolean key = Boolean.valueOf(fnd_key_bytes[0] == 1);
+                                //System.out.println("parsed KEY: " + key);
+
+                                Boolean search_key = key_to_search.getValueAs(Boolean.class);
+                                if (key.equals(search_key)) {
+                                    List<Object[]> record_i = storage_manager.get_records_from_block(tableName, block_id);
+                                    for (Object[] record : record_i) {
+                                        if (record[columnInd].equals(search_key)) {
+                                            records.add(record);
+                                        }
+                                    }
+                                    explored_block_records.add(block_id);
+                                }
+                                if (key.compareTo(search_key) > 0) {
+                                    break;
+                                }
+                            } else if (operand_type.equals("DOUBLE")) {
+                                Double key = Double.valueOf(ByteBuffer.wrap(fnd_key_bytes).getDouble());
+                                //System.out.println("parsed KEY: " + key);
+
+                                Double search_key = key_to_search.getValueAs(Double.class);
+                                if (key.equals(search_key)) {
+                                    List<Object[]> record_i = storage_manager.get_records_from_block(tableName, block_id);
+                                    for (Object[] record : record_i) {
+                                        if (record[columnInd].equals(search_key)) {
+                                            records.add(record);
+                                        }
+                                    }
+                                    explored_block_records.add(block_id);
+                                }
+                                if (key.compareTo(search_key) > 0) {
+                                    break;
+                                }
+                            } else if (operand_type.equals("FLOAT")) {
+                                Float key = Float.valueOf(ByteBuffer.wrap(fnd_key_bytes).getFloat());
+                                //System.out.println("parsed KEY: " + key);
+
+                                Float search_key = key_to_search.getValueAs(Float.class);
+                                if (key.equals(search_key)) {
+                                    List<Object[]> record_i = storage_manager.get_records_from_block(tableName, block_id);
+                                    for (Object[] record : record_i) {
+                                        if (record[columnInd].equals(search_key)) {
+                                            records.add(record);
+                                        }
+                                    }
+                                    explored_block_records.add(block_id);
+                                }
+                                if (key.compareTo(search_key) > 0) {
+                                    break;
+                                }
+                            } else if (operand_type.equals("VARCHAR")) {
+                                String key = new String(fnd_key_bytes);
+                                //System.out.println("parsed KEY: " + key);
+
+                                String search_key = key_to_search.getValueAs(String.class);
+                                if (key.equals(search_key)) {
+                                    List<Object[]> record_i = storage_manager.get_records_from_block(tableName, block_id);
+                                    for (Object[] record : record_i) {
+                                        if (record[columnInd].equals(search_key)) {
+                                            records.add(record);
+                                        }
+                                    }
+                                    explored_block_records.add(block_id);
+                                }
+                                if (key.compareTo(search_key) > 0) {
+                                    break;
+                                }
+                            }
+                            pointer += keyLen + 4;
+                        }
+                        if ((pointer < nextFreeOffset) || (next_leaf_block_id <= 0)) {
+                            break;
+                        }
+                        leaf_data = storage_manager.get_data_block(tableName + "_" + columnName + "_index", next_leaf_block_id);
+                    }
+                } else if (op_name.equals(">") || op_name.equals(">=")) {
+                    while (true) {
+                        int num_keys = (leaf_data[0] << 8) | (leaf_data[1] & 0xFF);
+                        //System.out.println(num_keys);
+                        int next_leaf_block_id = (leaf_data[4] << 8) | (leaf_data[5] & 0xFF);
+                        int nextFreeOffset = (leaf_data[6] << 8) | (leaf_data[7] & 0xFF);
+                        int pointer = 8, i = 0;
+                        while (pointer < nextFreeOffset) {
+                            int block_id = (leaf_data[pointer] << 8) | (leaf_data[pointer + 1] & 0xFF);
+                            int keyLen = (leaf_data[pointer + 2] << 8) | (leaf_data[pointer + 3] & 0xFF);
+                            if (explored_block_records.contains(block_id)) {
+                                pointer += keyLen + 4;
+                                continue;
+                            }
+
+                            byte[] fnd_key_bytes = new byte[keyLen];
+                            System.arraycopy(leaf_data, pointer + 4, fnd_key_bytes, 0, keyLen);
+                            if (operand_type.equals("INTEGER")) {
+                                Integer key = Integer.valueOf((fnd_key_bytes[0] << 24) | (fnd_key_bytes[1] << 16) | (fnd_key_bytes[2] << 8) | (fnd_key_bytes[3] & 0xFF));
+//                                System.out.println("parsed KEY: " + key);
+
+                                Integer search_key = key_to_search.getValueAs(Integer.class);
+                                if ((op_name.equals(">") && key.compareTo(search_key) > 0) || (op_name.equals(">=") && key.compareTo(search_key) >= 0)) {
+                                    List<Object[]> record_i = storage_manager.get_records_from_block(tableName, block_id);
+                                    for (Object[] record : record_i) {
+                                        if ((op_name.equals(">") && search_key.compareTo((Integer) record[columnInd]) < 0) || (op_name.equals(">=") && search_key.compareTo((Integer) record[columnInd]) <= 0)) {
+                                            records.add(record);
+                                        }
+                                    }
+                                    explored_block_records.add(block_id);
+                                }
+                            } else if (operand_type.equals("BOOLEAN")) {
+                                Boolean key = Boolean.valueOf(fnd_key_bytes[0] == 1);
+                                //System.out.println("parsed KEY: " + key);
+
+                                Boolean search_key = key_to_search.getValueAs(Boolean.class);
+                                if ((op_name.equals(">") && key.compareTo(search_key) > 0) || (op_name.equals(">=") && key.compareTo(search_key) >= 0)) {
+                                    List<Object[]> record_i = storage_manager.get_records_from_block(tableName, block_id);
+                                    for (Object[] record : record_i) {
+                                        if ((op_name.equals(">") && search_key.compareTo((Boolean) record[columnInd]) < 0) || (op_name.equals(">=") && search_key.compareTo((Boolean) record[columnInd]) <= 0)) {
+                                            records.add(record);
+                                        }
+                                    }
+                                    explored_block_records.add(block_id);
+                                }
+                            } else if (operand_type.equals("DOUBLE")) {
+                                Double key = Double.valueOf(ByteBuffer.wrap(fnd_key_bytes).getDouble());
+                                //System.out.println("parsed KEY: " + key);
+
+                                Double search_key = key_to_search.getValueAs(Double.class);
+                                if ((op_name.equals(">") && key.compareTo(search_key) > 0) || (op_name.equals(">=") && key.compareTo(search_key) >= 0)) {
+                                    List<Object[]> record_i = storage_manager.get_records_from_block(tableName, block_id);
+                                    for (Object[] record : record_i) {
+                                        if ((op_name.equals(">") && search_key.compareTo((Double) record[columnInd]) < 0) || (op_name.equals(">=") && search_key.compareTo((Double) record[columnInd]) <= 0)) {
+                                            records.add(record);
+                                        }
+                                    }
+                                    explored_block_records.add(block_id);
+                                }
+                            } else if (operand_type.equals("FLOAT")) {
+                                Float key = Float.valueOf(ByteBuffer.wrap(fnd_key_bytes).getFloat());
+                                //System.out.println("parsed KEY: " + key);
+
+                                Float search_key = key_to_search.getValueAs(Float.class);
+                                if ((op_name.equals(">") && key.compareTo(search_key) > 0) || (op_name.equals(">=") && key.compareTo(search_key) >= 0)) {
+                                    List<Object[]> record_i = storage_manager.get_records_from_block(tableName, block_id);
+                                    for (Object[] record : record_i) {
+                                        if ((op_name.equals(">") && search_key.compareTo((Float) record[columnInd]) < 0) || (op_name.equals(">=") && search_key.compareTo((Float) record[columnInd]) <= 0)) {
+                                            records.add(record);
+                                        }
+                                    }
+                                    explored_block_records.add(block_id);
+                                }
+                            } else if (operand_type.equals("VARCHAR")) {
+                                String key = new String(fnd_key_bytes);
+                                //System.out.println("parsed KEY: " + key);
+
+                                String search_key = key_to_search.getValueAs(String.class);
+                                if ((op_name.equals(">") && key.compareTo(search_key) > 0) || (op_name.equals(">=") && key.compareTo(search_key) >= 0)) {
+                                    List<Object[]> record_i = storage_manager.get_records_from_block(tableName, block_id);
+                                    for (Object[] record : record_i) {
+                                        if ((op_name.equals(">") && search_key.compareTo((String) record[columnInd]) < 0) || (op_name.equals(">=") && search_key.compareTo((String) record[columnInd]) <= 0)) {
+                                            records.add(record);
+                                        }
+                                    }
+                                    explored_block_records.add(block_id);
+                                }
+                            }
+                            pointer += keyLen + 4;
+                        }
+                        if (next_leaf_block_id <= 0) {
+                            break;
+                        }
+                        leaf_data = storage_manager.get_data_block(tableName + "_" + columnName + "_index", next_leaf_block_id);
+                    }
+                } else if (op_name.equals("<=") || op_name.equals("<")) {
+                    int prev_leaf_block_id = (leaf_data[2] << 8) | (leaf_data[3] & 0xFF);
+                    while (prev_leaf_block_id > 0) {
+                        leaf_data = storage_manager.get_data_block(tableName + "_" + columnName + "_index", prev_leaf_block_id);
+                        prev_leaf_block_id = (leaf_data[2] << 8) | (leaf_data[3] & 0xFF);
+                    }
+
+                    while (true) {
+                        int num_keys = (leaf_data[0] << 8) | (leaf_data[1] & 0xFF);
+                        //System.out.println(num_keys);
+                        int next_leaf_block_id = (leaf_data[4] << 8) | (leaf_data[5] & 0xFF);
+                        int nextFreeOffset = (leaf_data[6] << 8) | (leaf_data[7] & 0xFF);
+                        int pointer = 8, i = 0;
+                        while (pointer < nextFreeOffset) {
+                            int block_id = (leaf_data[pointer] << 8) | (leaf_data[pointer + 1] & 0xFF);
+                            int keyLen = (leaf_data[pointer + 2] << 8) | (leaf_data[pointer + 3] & 0xFF);
+                            if (explored_block_records.contains(block_id)) {
+                                pointer += keyLen + 4;
+                                continue;
+                            }
+
+                            byte[] fnd_key_bytes = new byte[keyLen];
+                            System.arraycopy(leaf_data, pointer + 4, fnd_key_bytes, 0, keyLen);
+                            if (operand_type.equals("INTEGER")) {
+                                Integer key = Integer.valueOf((fnd_key_bytes[0] << 24) | (fnd_key_bytes[1] << 16) | (fnd_key_bytes[2] << 8) | (fnd_key_bytes[3] & 0xFF));
+                                //System.out.println("parsed KEY: " + key);
+
+                                Integer search_key = key_to_search.getValueAs(Integer.class);
+                                if ((op_name.equals("<") && key.compareTo(search_key) < 0) || (op_name.equals("<=") && key.compareTo(search_key) <= 0)) {
+                                    List<Object[]> record_i = storage_manager.get_records_from_block(tableName, block_id);
+                                    for (Object[] record : record_i) {
+                                        if ((op_name.equals("<") && search_key.compareTo((Integer) record[columnInd]) > 0) || (op_name.equals("<=") && search_key.compareTo((Integer) record[columnInd]) >= 0)) {
+                                            records.add(record);
+                                        }
+                                    }
+                                    explored_block_records.add(block_id);
+                                } else {
+                                    break;
+                                }
+                            } else if (operand_type.equals("BOOLEAN")) {
+                                Boolean key = Boolean.valueOf(fnd_key_bytes[0] == 1);
+                                //System.out.println("parsed KEY: " + key);
+
+                                Boolean search_key = key_to_search.getValueAs(Boolean.class);
+                                if ((op_name.equals("<") && key.compareTo(search_key) < 0) || (op_name.equals("<=") && key.compareTo(search_key) <= 0)) {
+                                    List<Object[]> record_i = storage_manager.get_records_from_block(tableName, block_id);
+                                    for (Object[] record : record_i) {
+                                        if ((op_name.equals("<") && search_key.compareTo((Boolean) record[columnInd]) > 0) || (op_name.equals("<=") && search_key.compareTo((Boolean) record[columnInd]) >= 0)) {
+                                            records.add(record);
+                                        }
+                                    }
+                                    explored_block_records.add(block_id);
+                                } else {
+                                    break;
+                                }
+                            } else if (operand_type.equals("DOUBLE")) {
+                                Double key = Double.valueOf(ByteBuffer.wrap(fnd_key_bytes).getDouble());
+                                //System.out.println("parsed KEY: " + key);
+
+                                Double search_key = key_to_search.getValueAs(Double.class);
+                                if ((op_name.equals("<") && key.compareTo(search_key) < 0) || (op_name.equals("<=") && key.compareTo(search_key) <= 0)) {
+                                    List<Object[]> record_i = storage_manager.get_records_from_block(tableName, block_id);
+                                    for (Object[] record : record_i) {
+                                        if ((op_name.equals("<") && search_key.compareTo((Double) record[columnInd]) > 0) || (op_name.equals("<=") && search_key.compareTo((Double) record[columnInd]) >= 0)) {
+                                            records.add(record);
+                                        }
+                                    }
+                                    explored_block_records.add(block_id);
+                                } else {
+                                    break;
+                                }
+                            } else if (operand_type.equals("FLOAT")) {
+                                Float key = Float.valueOf(ByteBuffer.wrap(fnd_key_bytes).getFloat());
+                                //System.out.println("parsed KEY: " + key);
+
+                                Float search_key = key_to_search.getValueAs(Float.class);
+                                if ((op_name.equals("<") && key.compareTo(search_key) < 0) || (op_name.equals("<=") && key.compareTo(search_key) <= 0)) {
+                                    List<Object[]> record_i = storage_manager.get_records_from_block(tableName, block_id);
+                                    for (Object[] record : record_i) {
+                                        if ((op_name.equals("<") && search_key.compareTo((Float) record[columnInd]) > 0) || (op_name.equals("<=") && search_key.compareTo((Float) record[columnInd]) >= 0)) {
+                                            records.add(record);
+                                        }
+                                    }
+                                    explored_block_records.add(block_id);
+                                } else {
+                                    break;
+                                }
+                            } else if (operand_type.equals("VARCHAR")) {
+                                String key = new String(fnd_key_bytes);
+                                //System.out.println("parsed KEY: " + key);
+
+                                String search_key = key_to_search.getValueAs(String.class);
+                                if ((op_name.equals("<") && key.compareTo(search_key) < 0) || (op_name.equals("<=") && key.compareTo(search_key) <= 0)) {
+                                    List<Object[]> record_i = storage_manager.get_records_from_block(tableName, block_id);
+                                    for (Object[] record : record_i) {
+                                        if ((op_name.equals("<") && search_key.compareTo((String) record[columnInd]) > 0) || (op_name.equals("<=") && search_key.compareTo((String) record[columnInd]) >= 0)) {
+                                            records.add(record);
+                                        }
+                                    }
+                                    explored_block_records.add(block_id);
+                                } else {
+                                    break;
+                                }
+                            }
+                            pointer += keyLen + 4;
+                        }
+                        if ((pointer < nextFreeOffset) || (next_leaf_block_id <= 0)) {
+                            break;
+                        }
+                        leaf_data = storage_manager.get_data_block(tableName + "_" + columnName + "_index", next_leaf_block_id);
+                    }
+                }
+
+                return records;
+            }
         }
 }
\ No newline at end of file
